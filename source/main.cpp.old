////////////////////////////////////////////////////////////////////////////////
//
//  test app
//
////////////////////////////////////////////////////////////////////////////////


#include <new>
#include <cstdio>
#include <cstdlib>
#include "vmcore.hpp"
#include "vminline.hpp"
#include "vm_codemacros.hpp"

using namespace std;

////////////////////////////////////////////////////////////////////////////////
//
//  some quick embedded virtual code
//
////////////////////////////////////////////////////////////////////////////////


void nativePrintR1(VMCore *vm) // a quick native method
{
	printf("nativePrintR1() -> r1.s32 = %ld\n", vm->getReg(_r1).s32());
}

void nativePrintR1Hex(VMCore* vm)
{
	printf("nativePrintR1Hex() -> r1 = 0x%08X%08X\n", (unsigned)vm->getReg(_r1).getMSW(), (unsigned)vm->getReg(_r1).getLSW());
}

_VM_CODE(testJump) // a vm function
{
	_jump(_r1, 4), 0, 2, 4, 6,

	// case r1 = 0
	_ldq(15, _r1),
	_ret,

	// case r1 = 1
	_ldq(14, _r1),
	_ret,

	// case r1 = 2
	_ldq(13, _r1),
	_ret,

	// case r1 = 3
	_ldq(12, _r1),
	_ret
};

_VM_CODE(stuff)
{
	_xor_64(_r1, _r3),
	_rol_64(_r2, _r3),
	_ret
};

_VM_CODE(main) // the main vm function
{
	_calln(nativePrintR1),

	_ldq(0, _r1),
	_call(testJump),
	_calln(nativePrintR1),

	_ldq(1, _r1),
	_call(testJump),
	_calln(nativePrintR1),

	_ldq(2, _r1),
	_call(testJump),
	_calln(nativePrintR1),

	_ldq(3, _r1),
	_call(testJump),
	_calln(nativePrintR1),

	_ld_16_i8(32, _r2),

	_ld_32_i32(0x11223344, _r1),
	_calln(nativePrintR1Hex),
	_lsl_64(_r2, _r1),
	_calln(nativePrintR1Hex),
	_ld_32_i32(0x55667788, _r1),
	_calln(nativePrintR1Hex),
/*
	_iset(0),
	_ldq(1, _r1),
	_ld_32_i32(10000000, _r2),
	//_call(stuff),			// size : branch target
	_sub_32(_r1, _r2),	// 1 -17
	_sub_32(_r1, _r3),	// 1 -16
	_sub_32(_r1, _r4),	// 1 -15
	_sub_32(_r1, _r5),	// 1 -14
	_sub_32(_r1, _r6),	// 1 -13
	_sub_32(_r1, _r7),	// 1 -12
	_sub_32(_r1, _r8),	// 1 -11
	_sub_32(_r1, _r9),	// 1 -10
	_sub_32(_r1, _r10),	// 1  -9
 	_sub_32(_r1, _r11),	// 1  -8
 	_sub_32(_r1, _r12),	// 1  -7
 	_sub_32(_r1, _r13),	// 1  -6
	_sub_32(_r1, _r14),	// 1  -5
	_sub_32(_r1, _r15),	// 1  -4
	_sub_32(_r1, _r16),	// 1  -3
	_bnz_32(_r2, -17),	// 3	(-2, would be infinite)
*/
	_ret								//     0

};



////////////////////////////////////////////////////////////////////////////////

#define TEST_BUFFER_SIZE (1<<18)
uint16*			testBuffer = 0;
VMCore*			vm;
MilliClock	timeMS;

void timeNOP()
{
	printf("Benchmarking fetch/execute code\n\n");
 	for (sint32 e=0; e<16; e++) {
		float64 elapsed = 0.0;
  	uint16* p = testBuffer;
 		sint32 i;
 		if (e>0) {
			printf("Exception per %4ld ops : ", e);
 			for (i=TEST_BUFFER_SIZE; i>0; i--) {
		 		if ((i%e)==0)
		 			*p++ = _iset(0);
				else
 					*p++ = _nop|0x69;
 			}
 		} else {
 			printf("Zero exceptional ops   : ");
 			for (i=TEST_BUFFER_SIZE; i>0; i--) {
				*p++ = _nop|0xAB;
 			}
 		}
 		testBuffer[TEST_BUFFER_SIZE] = _brk;

 		for (i=0; i<4; i++) {
 			vm->setPC(testBuffer);
 			timeMS.set();
 			vm->execute();
 			elapsed += timeMS.elapsedFrac();
		}

 		sint32 insts = i*TEST_BUFFER_SIZE;
 		printf("%ld, %7.4f, %7.4f\n", insts, 0.001*elapsed, (0.001*(float64)insts)/elapsed );
	}
	printf("-------------------------------\n\n");
}

_VM_CODE(callTestReturn)
{
	_ret
};

_VM_CODE(callTest)
{
	_call(callTestReturn)
};

void timeCALL()
{
	printf("Benchmarking call/return pair\n\n");
	float64 elapsed = 0.0;
 	uint16* p = testBuffer;
	sint32 i;
	for (i=0; i<TEST_BUFFER_SIZE; i++) {
		*p++ = _VM_ENTRY(callTest)[0];
		*p++ = _VM_ENTRY(callTest)[1];
		*p++ = _VM_ENTRY(callTest)[2];
	}

	testBuffer[(3*TEST_BUFFER_SIZE)] = _brk;

	for (i=0; i<4; i++) {
		vm->setPC(testBuffer);
		timeMS.set();
		vm->execute();
		elapsed += timeMS.elapsedFrac();
	}

	sint32 insts = i*TEST_BUFFER_SIZE;
	printf("%ld, %7.4f, %7.4f\n", insts, 0.001*elapsed, (0.001*(float64)insts)/elapsed );
	printf("-------------------------------\n\n");
}

int main(int argc, char *argv[])
{
	printf("sizeof (VMDefs) = %u\n", sizeof(VMDefs));
	printf("sizeof (VMCore) = %u\n", sizeof(VMCore));
  printf("There are presently %d core instructions defined\n", VMDefs::MAX_OP);

	vm = new(nothrow) VMCore();
/*
  testBuffer = new(nothrow) uint16[(3*TEST_BUFFER_SIZE)+2];
  if (testBuffer) {
		timeNOP();
		timeCALL();
   	delete testBuffer;
  }
*/
	vm->dump();
	printf("Testing virtual code program\n");
	vm->setPC(_VM_ENTRY(main));
	vm->execute();
	vm->dump();
  delete vm;
  return 0;
}
